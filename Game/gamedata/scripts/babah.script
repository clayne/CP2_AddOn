-- -*- mode: lua; encoding: windows-1251 -*-
local math_random = math.random

-- функция для запуска таймера при ондропе
function timeBombOut(id, sect)
	start_real_timer("babah_drop_timeBomb", 0.2, {id = id, sect = sect})
end

-- функция для запуска таймера при ондропе
function mineOut(id, sect)
	start_real_timer("babah_drop_mine", 0.2, {id = id, sect = sect})
end

-- функция для запуска таймера при ондропе
function detonatorOut(id, sect)
	start_real_timer("babah_drop_detonator", 0.2, {id = id, sect = sect})
end

local bombs = {
	["sect"] = {
		["bomba"] = {
			["onLevels"] = {},
			["inInventory"] = {},
			["ids"] = {}
		},
		["bomba_small"] = {
			["onLevels"] = {},
			["inInventory"] = {},
			["ids"] = {}
		},
		["bomba_big"] = {
			["onLevels"] = {},
			["inInventory"] = {},
			["ids"] = {}
		}
	},
	["func"] = bombOut
}

local timeBombs = {
	["sect"] = {
		["bomba_timer_n_10"] = {
			["activated"] = "bomba_timer_n_10_activated",
			["base"] = "bomba_timer_n_10_base"
		},
		["bomba_timer_b_10"] = {
			["activated"] = "bomba_timer_b_10_activated",
			["base"] = "bomba_timer_b_10_base"
		},
		["bomba_timer_n_30"] = {
			["activated"] = "bomba_timer_n_30_activated",
			["base"] = "bomba_timer_n_30_base"
		},
		["bomba_timer_b_30"] = {
			["activated"] = "bomba_timer_b_30_activated",
			["base"] = "bomba_timer_b_30_base"
		}
	},
	["func"] = timeBombOut
}

local timeBombsBase = {
	["bomba_timer_n_10_base"] = {
		["inventory"] = "bomba_timer_n_10"
	},
	["bomba_timer_b_10_base"] = {
		["inventory"] = "bomba_timer_b_10"
	},
	["bomba_timer_n_30_base"] = {
		["inventory"] = "bomba_timer_n_30"
	},
	["bomba_timer_b_30_base"] = {
		["inventory"] = "bomba_timer_b_30"
	}
}

local timeBombsActivated = {
	["bomba_timer_n_10_activated"] = {
		["delay"] = 10
	},
	["bomba_timer_n_10_activated"] = {
		["delay"] = 10
	},
	["bomba_timer_n_30_activated"] = {
		["delay"] = 30
	},
	["bomba_timer_b_30_activated"] = {
		["delay"] = 30
	}
}

local mines = {
	["count"] = 0,
	["sect"] = {
		["bomba_mina_n"] = {
			["delay"] = 5,
			["onLevels"] = {},
			["inInventory"] = {},
			["ids"] = {}
		},
		["bomba_mina_b"] = {
			["delay"] = 5,
			["onLevels"] = {},
			["inInventory"] = {},
			["ids"] = {}
		}
	},
	["func"] = mineOut
}

local detonators = {
	["sect"] = {
		["detonator"] = {
			["probability"] = 0.75, -- вероятность удачного срабатывания, если нет секции - 1
			["delay"] = 2, -- задержка в секундах, если нет секции - 0
			["distance"] = 100,
			["id"] = -1,
			["name"] = "NK-32beta RUS",
			["has"] = false,
			["activated"] = false
		},
		["detonator_2"] = {
			["distance"] = 300,
			["id"] = -1,
			["name"] = "NK-37 RUS",
			["has"] = false,
			["activated"] = false
		}
	},
	["func"] = detonatorOut
}

local ignored_items = {
	["device_torch"]	= true,
	["device_pda"]		= true,
	["hand_radio"]		= true,
	["guitar_a"]		= true,
	["balalaika_a"]		= true,
	["harmonica_a"]		= true,
	["binocular_a"]		= true,
	["wpn_knife"]		= true,
	["wpn_binoc"]		= true,
	["bolt"]			= true,
	["yad"]				= true,
	["player"]			= true
}

local transferredBombs = {}
local explosivesAll

local funcBySect = {}
function collectFuncBySect(t)
	for k,v in pairs(t["sect"]) do
		funcBySect[k] = t["func"]
	end
end

collectFuncBySect(timeBombs)
--collectFuncBySect(mines)	-- для начала переделаем мины
--collectFuncBySect(bombs) -- будем искать бомбы только при срабатывании детонатора
collectFuncBySect(detonators)
--amk.dump_table(funcBySect)

function messg(news_text, header)
	--get_console():execute("load ~~~ function messg(news_text, header)"..tostring(news_text)..", "..tostring(header))
	if not news_text or not header then return end
	local player=xr_sound.get_safe_sound_object([[device\pda\pda_tip]])
	if player then
	player:play(Actor, 0, sound_object.s2d)
	local news_text = "%c[gray2]"..header.."\\n".."%c[default]"..news_text
		if Actor then
	Actor:give_game_news(news_text, "ui\\ui_VDGicon", Frect():set(0,47,83,47), 0, 5000)
		else
			get_console():execute("load ~~~ function messg(news_text, header) - Actor == nil")
		end
	else
		get_console():execute("load ~~~ function messg(news_text, header) - sound not found: "..[[device\pda\pda_tip]])
	end
end

function li(ob)
	if ob and _G["biznes_remove_special_item"]==nil then
		local id = ob:id()
		local sect = ob:section()
		local f = funcBySect[sect]
		if f then
			f(id, sect)
		end
		end
		end

function useDetonator(sect)
	--get_console():execute("load ~~~ function useDetonator(sect)")
	if level.main_input_receiver() then
		level.start_stop_menu(level.main_input_receiver(), true)
	end
	if detonators["sect"][sect]["delay"] then
		-- запускаем таймер отсрочки активации детонатора
		start_real_timer("babah_activateDetonator", detonators["sect"][sect]["delay"], sect)
	else
		explodeBombsByDetonator(sect)
	end
end

function explodeBombsByDetonator(sect)
	--get_console():execute("load ~~~ function explodeBombsByDetonator(sect)")
	local detonator = detonators["sect"][sect]
	if detonator then
		local probability = detonator["probability"]
		--get_console():execute("load ~~~ explodeBombsByDetonator(sect) sect: "..sect.." probability: "..tostring(probability))
		if probability then
			if math_random() > probability then
				messg("Ошибка детонатора!", detonator["name"])
				return
			end
		end
		local level_object_by_id = level.object_by_id
		local radius = detonator["distance"]
		local anyBombsExploded = false
		local actorPos = Actor:position()
		local invBoxExploded
		if Actor and AI and GGraph:valid_vertex_id(Actor:game_vertex_id()) then
			--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1")
			collectExplosivesAll()
			--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.2")
			local levelName = level.name()
			--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.3")
			explosivesOnLevel = explosivesAll["online"]["onLevelsInInventory"][levelName]
			--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.4")
			--get_console():execute("load ~~~ onLevelsInInventory "..levelName.." =")
			if explosivesOnLevel then
			--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.5")
				--amk.dump_table(explosivesOnLevel)
				for invBoxId, invBoxExplosives in pairs(explosivesOnLevel) do
					--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.6")
					if invBoxId ~= 0 then -- не подрываем у себя в рюкзаке
						invBox = level_object_by_id(invBoxId)
						if invBox and invBox:position():distance_to(actorPos) <= radius then
							--local isInventoryBox = (invBox:clsid() == clsid.inventory_box)
							--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.7")
							invBoxExploded = false
							for explSect, explIds in pairs(invBoxExplosives) do -- можно отсекать по секциям
								--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 1.8")
								if bombs["sect"][explSect] and explIds then
									for j = #explIds, 1, -1 do
										if explIds[j] then
											explosive = level_object_by_id(explIds[j])
											table.remove(explIds, j)
											if explosive then
												--[[if isInventoryBox then
												end]]
												--get_console():execute("load ~~~ explodeBombsByDetonator(id): 1.9 "..explosive:id())
												explode_r(explosive)
												anyBombsExploded = true
												invBoxExploded = true
												break
											end
										end
									end
									if invBoxExploded then
										explosivesOnLevel[invBoxId] = nil
										break
									end
								end
							end
						end
					end
				end
			end
			--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 2")
			explosivesOnLevel = explosivesAll["online"]["onLevels"][levelName]
			--get_console():execute("load ~~~ onLevels "..levelName.." =")
			if explosivesOnLevel then
				--amk.dump_table(explosivesOnLevel)
				--get_console():execute("load ~~~ explosivesAll:")
				--amk.dump_table(explosivesAll)
				for explSect, explIds in pairs(explosivesOnLevel) do -- можно отсекать по секциям
					if bombs["sect"][explSect] and explIds then
						for j = #explIds, 1, -1 do
							if explIds[j] then 
								explosive = level_object_by_id(explIds[j])
								if explosive and explosive:position():distance_to(actorPos) <= radius then
									table.remove(explIds, j)
									explode_r(explosive)
									anyBombsExploded = true
								end
							end
						end
					end
				end
				--get_console():execute("load ~~~ explosivesAll:")
				--amk.dump_table(explosivesAll)
			end
			if anyBombsExploded then
				messg("Взрывчатка взорвана!", detonator["name"])
			else
				messg("Ничего не взорвано!", detonator["name"])
			end
			--get_console():execute("load ~~~ explodeBombsByDetonator(sect): 3")
		end
	end
end

function dropMine(tbl)
	--get_console():execute("load ~~~ function dropMine(tbl)")
	if level.main_input_receiver() then
		level.start_stop_menu(level.main_input_receiver(), true)
	end
	-- запускаем таймер активации мины
	start_real_timer("babah_activateMine", mines["sect"][tbl.sect]["delay"], tbl)
end

function dropTimeBomb(tbl)
	--get_console():execute("load ~~~ function dropTimeBomb(tbl)")
	--start_real_timer("babah_timeBomb_activated", timeBombs["sect"][se_obj:section_name()]["delay"], se_obj.id)
	-- превращаем инвентарную бомбу в обычную
	if level.main_input_receiver() then
		level.start_stop_menu(level.main_input_receiver(), true)
	end
	if timeBombs["sect"][tbl.sect] then
		local obj = level.object_by_id(tbl.id)
		if obj then
			local sect = timeBombs["sect"][tbl.sect]["base"]
			local pos = obj:position()
			local lv = obj:level_vertex_id()
			local gv = obj:game_vertex_id()
			if not GGraph:valid_vertex_id(gv) then
				gv = Actor:game_vertex_id()
				if not GGraph:valid_vertex_id(gv) then -- похоже, что рядом нету вертекса
					messg("Здесь странное место...", "Локальная сеть")
					return
				end
			end
			del_obj_by_id(tbl.id)
			AI:create(sect, pos, lv, gv)
		end
	end
end

function relocateTimeBomb(tbl)
	--get_console():execute("load ~~~ function relocateTimeBomb(tbl)")
	--start_real_timer("babah_timeBomb_activated", timeBombs["sect"][se_obj:section_name()]["delay"], se_obj.id)
	-- превращаем обычную бомбу в инвентарную
	if transferredBombs[tbl.id] then
		transferredBombs[tbl.id] = nil
	elseif timeBombs["sect"][tbl.sect] then -- переложили из своего инвентаря
		local obj = level.object_by_id(tbl.id)
		local se_obj = AI:object(tbl.id)
		if obj and se_obj then
			local parent = obj:parent()
			local se_parent = AI:object(se_obj.parent_id)
			if parent then
				--amk.send_tip("relocateTimeBomb "..tbl.id.." "..tbl.sect.." "..obj:id().." "..obj:section().." "..obj:name().." parent "..parent:id().." "..parent:section().." "..parent:name())
				--amk.send_tip("relocateTimeBomb "..tbl.id.." "..tbl.sect.." "..se_obj.id.." "..se_obj:section_name().." "..se_obj:name().." parent "..se_parent.id.." "..se_parent:section_name().." "..se_parent:name())
				local sect = timeBombs["sect"][tbl.sect]["base"]
				local pos = se_parent.position
				local lv = se_parent.m_level_vertex_id
				local gv = se_parent.m_game_vertex_id
				if not GGraph:valid_vertex_id(gv) then
					gv = Actor:game_vertex_id()
					if not GGraph:valid_vertex_id(gv) then -- похоже, что рядом нету вертекса
						messg("Здесь странное место...", "Локальная сеть")
						return
					end
				end
				local parent_id = se_parent.id
				AI:release(se_obj, true)
				local new_se_obj = AI:create(sect, pos, lv, gv, parent_id)
				if parent:clsid() == clsid.inventory_box then
					-- ящики совсем охренели
					--amk.send_tip("ящики совсем охренели")
					start_real_timer("babah_timeBomb_transfer", 0.2, new_se_obj.id)
				end
			--	inventory.on_inventory_info("ui_inventory_hide")
			--	inventory.on_inventory_info("ui_inventory")
			end
		end
	end
end

function transferTimeBomb(id)
	--get_console():execute("load ~~~ function transferTimeBomb(id)")
	local obj = level.object_by_id(id)
	if obj and Actor then
		local invBox = obj:parent()
		if invBox then
			transferredBombs[id] = true
			invBox:transfer_item(obj, Actor)
			Actor:transfer_item(obj, invBox)

		--	inventory.on_inventory_info("ui_inventory_hide")
		--	inventory.on_inventory_info("ui_inventory")
			--amk.send_tip("transferTimeBomb(id)")
		end
	end
end

function on_item_take(obj)
	--get_console():execute("load ~~~ function on_item_take(obj)")
	-- превращаем обычную бомбу в инвентарную
	local id = obj:id()
	if transferredBombs[id] then
		transferredBombs[id] = nil
	elseif obj then
		local sect = obj:section()
		local timeBombBase = timeBombsBase[sect]
		if timeBombBase then -- переложили в свой инвентарь бомбу с таймером
			local parent = obj:parent()
			if parent then
				local newSect = timeBombBase["inventory"]
				local pos = parent:position()
				local lv = parent:level_vertex_id()
				local gv = parent:game_vertex_id()
				if not GGraph:valid_vertex_id(gv) then
					gv = Actor:game_vertex_id()
					if not GGraph:valid_vertex_id(gv) then -- похоже, что рядом нету вертекса
						messg("Здесь странное место...", "Локальная сеть")
						return
					end
				end
				local parent_id = parent:id()
				del_obj_by_id(id)
				AI:create(newSect, pos, lv, gv, parent_id)
			end
		end
	end
end

function useTimeBomb(tbl)
	--get_console():execute("load ~~~ function useTimeBomb(tbl)")
	if level.main_input_receiver() then
		level.start_stop_menu(level.main_input_receiver(), true)
	end
	if transferredBombs[tbl.id] then
		transferredBombs[tbl.id] = nil
	elseif Actor then
		local newSect = timeBombs["sect"][tbl.sect]["activated"]
		local delay = timeBombsActivated[newSect]["delay"]
		local pos = Actor:position()
		local lv = Actor:level_vertex_id()
		local gv = Actor:game_vertex_id()
		if not GGraph:valid_vertex_id(gv) then -- похоже, что рядом нету вертекса
			messg("Здесь странное место...", "Локальная сеть")
			return
		end
		se_obj = AI:create(newSect, pos, lv, gv, Actor:id())
		start_real_timer("babah_timeBomb_activated", delay, se_obj.id)
		messg("Таймер запущен! Нужно срочно выложить взрывчатку и отойти на безопасное расстояние.", "Взрывчатка")
	end
end

function explosiveExplode(id)
	--get_console():execute("load ~~~ function explosiveExplode(id)")
	--amk.send_tip("пробуем взорвать")
	local level_object_by_id = level.object_by_id
	local se_obj = AI:object(id)
	if se_obj then
		local obj = level_object_by_id(id)
		if obj then
			-- проверка на то, что взрывчатку кто-то подобрал
			if se_obj.parent_id and se_obj.parent_id ~= 65535 then
				-- перемещаем её к хозяину
				local sect = obj:section()
				local parent = level_object_by_id(se_obj.parent_id)
				if parent then
					if parent:clsid() == clsid.inventory_box then
						collectExplosivesAll()
						explode_r(obj)
					else
						local pos = parent:position()
						local lv = parent:level_vertex_id()
						local gv = parent:game_vertex_id()
						if not GGraph:valid_vertex_id(gv) then -- похоже, что рядом нету вертекса
							messg("Здесь странное место...", "Локальная сеть")
							return
						end
						AI:release(se_obj, true)
						se_obj = AI:create(sect, pos, lv, gv, parent:id())
						start_real_timer("babah_explode_moved_timeBomb", 0.2, se_obj.id)
						--amk.send_tip("Взрывчатка перемещена "..type(se_obj.id).." "..tostring(se_obj.id))
					end
				end
			else
				collectExplosivesAll()
				explode_r(obj)
				amk.send_tip("Взрывчатка взорвана", nil, 4)
			end
		else -- объект на другой территории или в оффлайне
			collectExplosivesAll()
			explodeOffline(se_obj, true)
		end
	end
end

function collectExplosivesAll()
	--get_console():execute("load ~~~ function collectExplosivesAll()")
	-- собираем информацию о взрывчатках
	explosivesAll = {
		["online"] = {
			["onLevels"] = {},
			["onLevelsInInventory"] = {},
		},
		["offline"] = {
			["onLevels"] = {},
			["onLevelsInInventory"] = {},
		},
		--["ids"] = {},
		--["count"] = 0
	}
	local explOnlineOnLevels = explosivesAll["online"]["onLevels"]
	local explOnlineOnLevelsInInventory = explosivesAll["online"]["onLevelsInInventory"]
	local explOfflineOnLevels = explosivesAll["offline"]["onLevels"]
	local explOfflineOnLevelsInInventory = explosivesAll["offline"]["onLevelsInInventory"]
	local level_object_by_id = level.object_by_id
	local levelName
	local correct
	local parent_id
	local obj, se_obj, p_obj
	local explTmp
	local t
	local sect
	for i = 1, 65534 do
		se_obj = AI:object(i)
		if se_obj and se_obj:clsid() == clsid.obj_explosive then
			sect = se_obj:section_name()
			correct = false
			parent_id = se_obj.parent_id
			
			if parent_id and parent_id ~= 65535 then
				-- в коллекцию по инвентарям
				p_obj = AI:object(parent_id)
				if p_obj and GGraph:valid_vertex_id(p_obj.m_game_vertex_id) then
					levelName = object_level_name(p_obj)
					obj = level_object_by_id(parent_id)
					if obj then
						explTmp = explOnlineOnLevelsInInventory
					else
						explTmp = explOfflineOnLevelsInInventory
					end
					if not explTmp[levelName] then
						explTmp[levelName] = {}
					end
					if not explTmp[levelName][parent_id] then
						explTmp[levelName][parent_id] = {}
					end
					if not explTmp[levelName][parent_id][sect] then
						explTmp[levelName][parent_id][sect] = {}
					end
					t = explTmp[levelName][parent_id][sect]
					table.insert(t, i)
					correct = true
					--get_console():execute("load ~~~ collectExplosivesAll(): "..se_obj.id.." name - "..se_obj:name().." sect - "..se_obj:section_name()..", parent_id - "..tostring(se_obj.parent_id))
				end
			elseif GGraph:valid_vertex_id(se_obj.m_game_vertex_id) then
				-- в коллекцию по уровням
				levelName = object_level_name(se_obj)
				obj = level_object_by_id(i)
				if obj then
					explTmp = explOnlineOnLevels
				else
					explTmp = explOfflineOnLevels
				end
				if not explTmp[levelName] then
					explTmp[levelName] = {}
				end
				if not explTmp[levelName][sect] then
					explTmp[levelName][sect] = {}
	end
				t = explTmp[levelName][sect]
				table.insert(t, i)
				correct = true
			end
			
			if correct then
				-- в общую коллекцию
				--t = explosivesAll["ids"]
				--table.insert(t, i)
				--explosivesAll["count"] = explosivesAll["count"] + 1
			else
				get_console():execute("load ~~~ FAILED collectExplosivesAll(): "..se_obj.id.." sect - "..se_obj:section_name()..", parent_id - "..tostring(se_obj.parent_id))
			end
		end
	end
	--get_console():execute("load ~~~ collectExplosivesAll():")
	--amk.dump_table(explosivesAll)
end

function explodeMovedTimeBomb(id)
	--get_console():execute("load ~~~ function explodeMovedTimeBomb(id)")
	--amk.send_tip("Взрывчатка взорвана id "..type(id).." "..tostring(id))
	local se_obj = AI:object(id)
	--amk.send_tip("Взрывчатка взорвана se_obj.id "..type(se_obj.id).." "..tostring(se_obj.id).." section: "..se_obj:section_name(), nil, 3)
	local obj = level.object_by_id(se_obj.id)
	--amk.send_tip("Взрывчатка взорвана obj "..type(obj), nil, 4)
	--amk.send_tip("Взрывчатка взорвана obj.id "..type(obj:id()).." "..tostring(obj:id()), nil, 4)
	if obj and se_obj then
		collectExplosivesAll()
		explode_r(obj)
	end
end

local itemsTransferBack = {}

function explode_r(ob)
	--get_console():execute("load ~~~ function explode_r(ob)")
	if ob then
		hitExplosive(ob)
		--collectExplosivesAll()
		
		local level_object_by_id = level.object_by_id
		local obj = ob
		local parent_id
		if ob:parent() then
			parent_id = ob:parent():id()
			if parent_id and parent_id ~= 65535 then
				obj = level_object_by_id(parent_id) -- получаем объект хозяина
			end
		end

		local id = ob:id()
		local pos = obj:position()
		local sect = ob:section()
		if obj:id() ~= id then -- взрывчатка в инвентаре
			if (obj.character_community and obj:character_community() == "trader") or
				rx_utils.read_from_ini(nil, obj:section(), "immunities_sect", "", 1) == "stalker_immunities_sakharov"
			then -- чтобы не трясли торговцев и бессмертных неписей
				local h = hit()
				h.power = 100
				h.impulse = 0
				h.draftsman = Actor
				h.direction = vector():set(0,0,0)
				h.type = hit.fire_wound
				obj:hit(h)
				Actor:set_character_community("monolith", 0, 0)
				return
			end
			--if obj:clsid() == clsid.inventory_box then
				pos.y = pos.y + 0.5
			--end
			local lv = obj:level_vertex_id()
			local gv = obj:game_vertex_id()
			if not GGraph:valid_vertex_id(gv) then -- похоже, что рядом нету вертекса
				messg("Здесь странное место...", "Локальная сеть")
				return
			end
			--get_console():execute("load ~~~ babah pos: x "..pos.x..", y "..pos.y..", z "..pos.z..", lv "..lv..", gv "..gv)
			-- удаляем всё из инвентаря
			--amk.send_tip("удаляем всё из инвентаря")
			local isNPC = obj:clsid()==clsid.script_stalker or IAmAMonster[obj:clsid()]
--			if isNPC then
--				particles_object("anomaly2\\body_tear_01"):play_at_pos(pos)
--			end
			
			itemsTransferBack = {}
			if isNPC and obj:alive() then
			--	shiftCheckDropItem()
				obj:iterate_inventory(
					function(dummy,item)
						if item:id() ~= id and not ignored_items[item:section()] then
							obj:drop_item(item)
							--AI:create(item:section(), pos, lv, gv)
							--AI:release(AI:object(item:id()))
						end
					end,
					obj
				)
			else -- для тайников и трупов
				if Actor then
					local packet
					local sect, se_obj
					local items = {}
					local inv_obj
					for i = 1, 65534 do
						if i ~= id then
							se_obj = AI:object(i)
							if se_obj and se_obj.parent_id == parent_id then
								--amk.send_tip("babah (se_obj.parent_id == parent_id): id "..se_obj.id..", name "..se_obj:name())
								--get_console():execute("load ~~~ babah (se_obj.parent_id == parent_id): id "..se_obj.id..", name "..se_obj:name()..", online "..tostring(se_obj.online))
								inv_obj = level_object_by_id(se_obj.id)
								if inv_obj then
									--amk.send_tip("babah (inv_obj:parent():id() == parent_id): id "..inv_obj:id()..", name "..inv_obj:name())
									--get_console():execute("load ~~~ babah (inv_obj:parent():id() == parent_id): id "..inv_obj:id()..", name "..inv_obj:name())
									if isNPC then
										obj:drop_item(inv_obj)
									else
										if se_obj.online then
											sect = inv_obj:section()
											if timeBombs["sect"][sect] or timeBombsActivated[sect] or timeBombsBase[sect] then
												transferredBombs[i] = true
											end
											obj:transfer_item(inv_obj, Actor)
											-- собираем предметы для следующей переброски обратно в тайник, иначе - вылет, если какой-то из предметов подходит в пустой слот оружия и ГГ не имеет в данный момент активного предмета в руках
											table.insert(itemsTransferBack, se_obj.id)
										end
									end
								else
									amk.send_tip("babah obj == nil: id "..se_obj.id..", name "..se_obj:name())
									get_console():execute("load ~~~ function explode_r(ob) - babah obj == nil: id "..se_obj.id..", name "..se_obj:name())
								end
							end
						end
					end
				end
			end
			if #itemsTransferBack > 0 then
				start_real_timer("babah_transfer_items", 0.1, {invId = obj:id(), explId = id, itemsTransferBack = itemsTransferBack})
			else
				hitExplosive(ob)
				start_real_timer("babah_explode_biside_explosives", 0.5, {id = id, sect = sect, x = pos.x, y = pos.y - 0.5, z = pos.z, lvl = level.name()})
			end
		else
			hitExplosive(ob)
			start_real_timer("babah_explode_biside_explosives", 0.5, {id = id, sect = sect, x = pos.x, y = pos.y - 0.5, z = pos.z, lvl = level.name()})
		end
	else
		amk.send_tip("Взрывчатка не взорвана. Она не найдена.", nil, 2)
	end
end

function itemsTransferBackToInventory(tbl)
	local level_object_by_id = level.object_by_id
	local inventory = level_object_by_id(tbl.invId)
	if inventory then
		local pos = inventory:position()
		pos.y = pos.y + 0.5
		local lv = inventory:level_vertex_id()
		local gv = inventory:game_vertex_id()
		if not GGraph:valid_vertex_id(gv) then -- похоже, что рядом нету вертекса
			messg("Здесь странное место...", "Локальная сеть")
			return
		end
		local obj, se_obj
		local packet
		local sect
		shiftCheckDropItem()
		for i = 1, #tbl.itemsTransferBack do
			obj = level_object_by_id(tbl.itemsTransferBack[i])
			se_obj = AI:object(tbl.itemsTransferBack[i])
			if obj and se_obj and obj:parent() and obj:parent():id() == 0 then
				sect = obj:section()
				Actor:transfer_item(obj, inventory)
				packet = net_packet() -- создаём пустой пакет
				se_obj:STATE_Write(packet) -- загрузили в наш пакет состояние серверного объекта
				-- используя методы класса net_packet меняем нужные нам значения.
				AI:release(se_obj, true)
				se_obj = AI:create(sect, pos, lv, gv)
				se_obj:STATE_Read(packet, packet:w_tell()) -- записали в объект изменённое состояние обратно, имитируя процесс его загрузки
			end
		end
		itemsTransferBack = {}
		local explosive = level_object_by_id(tbl.explId)
		if explosive then
			hitExplosive(explosive)
		end
		start_real_timer("babah_explode_biside_explosives", 0.5, {id = explosive:id(), sect = explosive:section(), x = pos.x, y = pos.y - 0.5, z = pos.z, lvl = level.name()})
	else
		get_console():execute("load ~~~ function itemsTransferBackToInventory(tbl) - inventory == nil: id "..tostring(tbl.invId))
	end
end

function explodeBisideExplosives(tbl)
	--get_console():execute("load ~~~ function explodeBisideExplosives(tbl)")
	--amk.send_tip("Взрываем взрывчатку рядом")
	local level_object_by_id = level.object_by_id
	local explosivesOnLevel
	local explosive
	local explId = tbl.id
	local levelNameExplosive = tbl.lvl
	local explPos = vector():set(tbl.x, tbl.y, tbl.z)
	local infoExplosive = collectExplosiveInfo(tbl.sect)
	--amk.dump_table(infoExplosive)
	local radius = infoExplosive["blast_r"]
	--if infoExplosive["frags"] > 0 then
	--	radius = math.max(radius, infoExplosive["frags_r"]) -- слишком далеко достают осколки
	--end
	--get_console():execute("load ~~~ function explodeBisideExplosives(tbl) 1")
		-- подрываем взрывчатку рядом
	--get_console():execute("load ~~~ explosivesAll:")
	--amk.dump_table(explosivesAll)
	local invBox
	local invBoxExploded
	explosivesOnLevel = explosivesAll["online"]["onLevelsInInventory"][levelNameExplosive]
	--get_console():execute("load ~~~ onLevelsInInventory "..levelNameExplosive.." =")
	--get_console():execute("load ~~~ function explodeBisideExplosives(tbl) 2")
	if explosivesOnLevel then
		--amk.dump_table(explosivesOnLevel)
		for invBoxId, invBoxExplosives in pairs(explosivesOnLevel) do
		--get_console():execute("load ~~~ function explodeBisideExplosives(tbl) 3")
			invBox = level_object_by_id(invBoxId)
			invBoxExploded = false
			if invBox and invBox:position():distance_to(explPos) <= radius then
				for sect, explIds in pairs(invBoxExplosives) do -- можно отсекать по секциям
					if explIds then
						for j = #explIds, 1, -1  do -- а здесь можно и с предметами в инвентаре что-то сделать, если их запомнить вместе со взрывчаткой перед этим
							if explIds[j] then
								if explIds[j] ~= explId then
									explosive = level_object_by_id(explIds[j])
									table.remove(explIds, j)
									if explosive then
										invBoxExploded = true
										explode_r(explosive)
										break
									end
								else
									table.remove(explIds, j)
								end
							end
						end
					end
					if invBoxExploded then
						explosivesOnLevel[invBoxId] = nil
						break
					end
				end
			end
		end
	end
	--get_console():execute("load ~~~ function explodeBisideExplosives(tbl) 4")
	explosivesOnLevel = explosivesAll["online"]["onLevels"][levelNameExplosive]
	--get_console():execute("load ~~~ onLevels "..levelNameExplosive.." =")
	if explosivesOnLevel then
		--amk.dump_table(explosivesOnLevel)
		--get_console():execute("load ~~~ explosivesAll:")
		--amk.dump_table(explosivesAll)
		for sect, explIds in pairs(explosivesOnLevel) do -- можно отсекать по секциям
			--get_console():execute("load ~~~ function explodeBisideExplosives(tbl) 5")
			if explIds then
				for j = #explIds, 1, -1 do
					if explIds[j] then 
						if explIds[j] ~= explId then
							explosive = level_object_by_id(explIds[j])
							if explosive and explosive:position():distance_to(explPos) <= radius then
								table.remove(explIds, j)
								explode_r(explosive)
							end
						else
							table.remove(explIds, j)
						end
					end
				end
			end
		end
		--get_console():execute("load ~~~ explosivesAll:")
		--amk.dump_table(explosivesAll)
	end
	--get_console():execute("load ~~~ function explodeBisideExplosives(tbl) finish")
end

function hitExplosive(ob)
	--get_console():execute("load ~~~ function hitExplosive(ob)")
	if ob then
		--amk.send_tip("Наносим повреждение взрывчатке: id "..ob:id()..", name "..ob:name())
	local h = hit()
	h.power = 2000
	h.impulse = 100
	h.draftsman = ob
	h.direction = vector():set(0,0,0)
	h.type = hit.explosion
	ob:hit(h)
end
end

function collectBombs(se_obj)
	if se_obj.parent_id == 65535 then -- лежит на земле
		local sect = se_obj:section_name()
		if mines["sect"][sect] then
			addMine(se_obj)
		end
	end
end

function addMine(se_obj)
	if se_obj then
		local sect = se_obj:section_name()
		local mine = mines["sect"][sect]
		if mine then
			local levelName
			local correct = false
			local parent_id = se_obj.parent_id

			if parent_id == 65535 and GGraph:valid_vertex_id(se_obj.m_game_vertex_id) then
				-- в коллекцию по уровням
				levelName = object_level_name(se_obj)
				if not mine["onLevels"][levelName] then
					mine["onLevels"][levelName] = {}
				end
				local t = mine["onLevels"][levelName]
				table.insert(t, se_obj.id)
				correct = true
			end
			
			if correct then
				-- в общую коллекцию
				local t = mine["ids"]
				table.insert(t, se_obj.id)
				mines["count"] = mines["count"] + 1
			else
				get_console():execute("load ~~~ FAILED addMine(): "..se_obj.id.." sect - "..sect..", parent_id - "..tostring(se_obj.parent_id))
			end
		end
	end
		--get_console():execute("load ~~~ addMine+")
		--amk.dump_table(mines)
		--get_console():execute("load ~~~ addMine-")
end


function update(delta)
	if mines["count"] > 0 then
		local npcOnline = db.creatures
		local npcOffline = amk_offline_alife.off_npcs
		if npcOnline and npcOffline then
			local npcObj, mineObj
			local level_object_by_id = level.object_by_id
			local onLevels, inInventory, ids
			local mineId, parentId
			local minePos
			local found = false
			local levelOfflineData, offlineNPCs
			local actorLevelName = level.name()
			-- проверяем на расстояние между минами и онлайновыми неписями
			for k,v in pairs(mines["sect"]) do
				onLevels = v["onLevels"]
				for levelName, levelData in pairs(onLevels) do
					if levelData then
						for i = #levelData, 1, -1 do
							mineId = levelData[i]
							if mineId then
								mineObj = AI:object(mineId)
								if mineObj then
									parentId = mineObj.parent_id
									-- если кто-то поднял мину (ловкий парень :))
									if parentId and parentId ~= 65535 then
										-- перемещаем мину в список по инвентарям и не взрываем
										inInventory = v["inInventory"]
										table.insert(inInventory, mineId)
										table.remove(levelData, i)
									else
										minePos = mineObj.position
										-- поиск в онлайне
										if actorLevelName == levelName then
											for npcId, npc in pairs(npcOnline) do
												npcObj = level_object_by_id(npcId)
												if npcObj and npcObj:is_alive() and npcObj:position():distance_to(minePos) <= 1.5 then
													found = true
													break
												end
											end
										end
										-- поиск в оффлайне
										levelOfflineData = npcOffline[levelName]
										if levelOfflineData then
											--get_console():execute("load ~~~ levelOfflineData-")
											--amk.dump_table(levelOfflineData["monsters"])
											--amk.dump_table(levelOfflineData["stalkers"])
											--get_console():execute("load ~~~ levelOfflineData-")
											if not found then
												offlineNPCs = levelOfflineData["monsters"]
												if offlineNPCs then
													for j = 1, #offlineNPCs do
														if offlineNPCs[j]["id"] then
															npcObj = AI:object(offlineNPCs[j]["id"])
															if npcObj and npcObj:alive() and npcObj.position:distance_to(minePos) <= 1.5 then
																found = true
																break
															end
														end
													end
												end
											end
											if not found then
												offlineNPCs = levelOfflineData["stalkers"]
												if offlineNPCs then
													for j = 1, #offlineNPCs do
														if offlineNPCs[j]["id"] then
															npcObj = AI:object(offlineNPCs[j]["id"])
															if npcObj and npcObj:alive() and npcObj.position:distance_to(minePos) <= 1.5 then
																found = true
																break
															end
														end
													end
												end
											end
										end
										if found then
											-- удаляем мину из таблицы
											--get_console():execute("load ~~~ MINES babah: "..mineId)
											--amk.dump_table(mines)
											--get_console():execute("load ~~~ MINES babah+")
											table.remove(levelData, i)
											ids = v["ids"]
											for j = #ids, 1, -1 do
												if ids[j] == mineId then
													table.remove(ids, j)
													break
												end
											end
											mines["count"] = mines["count"] - 1
											found = false
											--amk.dump_table(mines)
											--get_console():execute("load ~~~ MINES babah-")
											-- взрываем мину
											explosiveExplode(mineId)
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

-- подрыв в оффлайне
function explodeOffline(se_obj, first)
	--amk.send_tip("пробуем взорвать на другой территории")
	if se_obj then
		local infoExplosive = collectExplosiveInfo(se_obj:section_name())
		--amk.dump_table(infoExplosive)
		local radius = infoExplosive["blast_r"]
		if infoExplosive["frags"] > 0 then
			radius = math.max(radius, infoExplosive["frags_r"])
		end

		local obj = se_obj
		local parent_id = se_obj.parent_id
		if parent_id and parent_id ~= 0 and parent_id ~= 65535 then
			obj = AI:object(parent_id) -- получаем объект хозяина
		end

		if GGraph:valid_vertex_id(obj.m_game_vertex_id) then
			local infoVictimsOffline = collectExplosiveVictimsOffline(obj, radius)
			--amk.dump_table(infoVictimsOffline)
			
			damageVictimsOffline(infoVictimsOffline, infoExplosive)
			if first then
				--local packet
				local explosivesOnLevel
				local explosive
				local explId = se_obj.id
				local explPos = obj.position
				local levelNameExplosive = object_level_name(obj)
				-- взрывчатка отработала
				AI:release(se_obj, true)
				-- подрываем взрывчатку рядом
				--amk.dump_table(explosivesAll)
				local invBox
				explosivesOnLevel = explosivesAll["offline"]["onLevelsInInventory"][levelNameExplosive]
				if explosivesOnLevel then
					for invBoxId, invBoxExplosives in pairs(explosivesOnLevel) do
						invBox = AI:object(invBoxId)
						if invBox and invBox.position:distance_to(explPos) <= radius then
							for sect, explIds in pairs(invBoxExplosives) do -- можно отсекать по секциям
								if explIds then
									for j = #explIds, 1, -1 do -- а здесь можно и с предметами в инвентаре что-то сделать, если их запомнить вместе со взрывчаткой перед этим
										if explIds[j] then
											if explIds[j] ~= explId then
												explosive = AI:object(explIds[j])
												table.remove(explIds, j)
												if explosive then
													explodeOffline(explosive, true)
												end
											else
												table.remove(explIds, j)
											end
										end
									end
								end
							end
						end
					end
				end
				explosivesOnLevel = explosivesAll["offline"]["onLevels"][levelNameExplosive]
				if explosivesOnLevel then
					--amk.dump_table(explosivesAll)
					for sect, explIds in pairs(explosivesOnLevel) do -- можно отсекать по секциям
						if explIds then
							for j = #explIds, 1, -1 do
								if explIds[j] then 
									if explIds[j] ~= explId then
										explosive = AI:object(explIds[j])
										if explosive and explosive.position:distance_to(explPos) <= radius then
											table.remove(explIds, j)
											explodeOffline(explosive, true)
										end
									else
										table.remove(explIds, j)
									end
								end
							end
						end
					end
					--amk.dump_table(explosivesAll)
				end
			else
				AI:release(se_obj, true)
			end
			if first then
				messg("Взорвано на другой территории.", "Взрывчатка")
			end
		else
			if first then
				amk.send_tip("Взрывчатка НЕ взорвана! Она в кривом месте...", nil, 2)
			end
		end
	end
end

-- для кеширования данных
local explosivesInfo = {}

function collectExplosiveInfo(section)
	if not explosivesInfo[section] then
		local explosive = {
			["blast"] = 1.5,
			["blast_r"] = 2,
			["blast_impulse"] = 200,
			["blast_impulse_factor"] = 1,
			["frags"] = 0,
			["frags_r"] = 15,
			["frag_hit"] = 0.25,
			["frag_hit_impulse"] = 150,
			["hit_type_blast"] = "explosion",
			["hit_type_frag"] = "burn"
		}
		local varType
		for k, v in pairs(explosive) do
			varType = type(v)
			if varType == "number" then
				explosive[k] = sys_ini:r_float_ex(section, k, v)
			elseif varType == "string" then
				explosive[k] = sys_ini:r_string_ex(section, k, v)
			end
		end
		
		explosivesInfo[section] = explosive
	end
	
	return explosivesInfo[section]
end

-- собираем информацию о жертвах
-- код повзаимствован из amk_offline_alife.offline_alife()
function collectExplosiveVictimsOffline(se_obj, radius)
	local vdata = {}
	if GGraph:valid_vertex_id(se_obj.m_game_vertex_id) then
		local map = object_level_name(se_obj)
		local off_npcs = amk_offline_alife.off_npcs
		local explPos = se_obj.position
		
		-- по сталкерам
		
		local function collectNPCs(offNPCs)
			if offNPCs then
				local offNPC
				local victim
				local sect
				local dist
				for a = 1, #offNPCs do
					offNPC = offNPCs[a]
					if offNPC then
						victim = AI:object(offNPC.id)
						if victim and victim.health and victim:health() > 0
								and victim.can_switch_online and victim:can_switch_online()
								and victim:name() == offNPC.name then
							sect = victim:section_name()
							dist = explPos:distance_to(victim.position)
							if dist <= radius then
								table.insert(vdata, {["id"] = victim.id, ["dist"] = dist, ["squere"] = getVictimSquare(sect)})
							end
						end
					end
				end
			end
		end
		
		collectNPCs(off_npcs[map].stalkers)
		collectNPCs(off_npcs[map].monsters)
	end

	return vdata
end

-- для кеширования данных
local victimsSquare = {}

function getVictimSquare(sect)
	if not victimsSquare[sect] then
		local victimSize = {0.5, 0.9, 0.5}
		local tmp = parse_nums(getIniValueString(sect, "ph_box0_size", table.concat(victimSize,", "), nil))
		if #tmp == 3 then
			victimSize = tmp
		end
		victimsSquare[sect] = (victimSize[1] + victimSize[3]) / 2 * victimSize[2]
	end

	return victimsSquare[sect]
end

function damageVictimsOffline(infoVictimsOffline, infoExplosive)
	local se_obj
	local damage
	local health
	for i = 1, #infoVictimsOffline do
		se_obj = AI:object(infoVictimsOffline[i].id)
		if se_obj then
			damage = calcDamageForVictim(infoVictimsOffline[i], infoExplosive)
			if damage > 0 then
				health = se_obj:health() - damage
				if health < 0 then
					health = 0
				end
				amk_offline_alife.set_npc_health(se_obj, health)
			end
		end
	end
end

function calcDamageForVictim(victimInfo, infoExplosive)
	local rNorm = victimInfo["dist"] / infoExplosive["blast_r"]
	local damage = 0
	if victimInfo["dist"] < infoExplosive["blast_r"] then
		damage = infoExplosive["blast"] * (1 - rNorm * rNorm) * victimInfo["squere"]
		-- (1 - x ^ 2) http://yotx.ru/default.aspx?clr0=000000&exp0=1+-+x*x&mix=0&max=1&asx=on&u=mm&nx=X&aiy=on&asy=on&ny=Y&iw=600&ih=400&ict=png&aa=on
	end
	if infoExplosive["frags"] > 0 and victimInfo["dist"] < infoExplosive["frags_r"] then
		-- вероятность попадания
		local sphereSquere = 4 * math.pi * victimInfo["dist"] * victimInfo["dist"]
		local prob = victimInfo["squere"] / sphereSquere
		for i = 1, infoExplosive["frags"] do
			if math_random() < prob then
				damage = damage + infoExplosive["frag_hit"]
			end
		end
	end
	-- его величество Случай
	damage = damage * (1 - math_random()*math_random()*math_random()*math_random())

	return damage
end
